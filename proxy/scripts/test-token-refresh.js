/**
 * @description
 * Tests the Sitecore Identity OAuth token refresh flow end-to-end.
 * Loads existing tokens from tokens.json, uses the refresh token to
 * obtain a new access token, reports on the old vs new expiry times,
 * checks whether the refresh token was rotated, and persists the
 * updated tokens back to disk.
 *
 * This script validates that:
 * 1. The refresh token from auth.js is still valid
 * 2. Sitecore's token endpoint returns a fresh access token
 * 3. The new access token has a reasonable TTL
 * 4. The refresh token rotation policy is identified (rotated vs reused)
 * 5. Updated tokens are saved in the same format expected by mcp-client.js
 *
 * Key features:
 * - Zero dependencies beyond Node.js built-ins (uses native fetch)
 * - Matches the token file format used by auth.js and mcp-client.js
 * - Reports clear pass/fail status for CI or manual validation
 * - Non-destructive: backs up old token info in console output before overwriting
 *
 * Usage:
 *   # Set env vars (or export them in your shell)
 *   export SITECORE_CLIENT_ID=your-client-id
 *   export SITECORE_TOKEN_URL=https://auth.sitecorecloud.io/oauth/token
 *   export SITECORE_AUDIENCE=https://api.sitecorecloud.io
 *
 *   # Run from the proxy directory
 *   cd proxy && node scripts/test-token-refresh.js
 *
 * @dependencies
 * - node:fs: Read/write tokens.json
 * - node:path: Resolve token file path
 * - Native fetch (Node 22+): HTTP POST to token endpoint
 *
 * @notes
 * - Requires tokens.json to already exist (generated by scripts/auth.js)
 * - The script reads SITECORE_CLIENT_ID from env (required)
 * - SITECORE_CLIENT_SECRET is optional (empty for PKCE public clients)
 * - SITECORE_TOKEN_URL and SITECORE_AUDIENCE have sensible defaults
 * - The token file format matches both auth.js output and mcp-client.js expectations
 * - If Sitecore rotates the refresh token, the new one is saved automatically
 */

import { readFileSync, writeFileSync, existsSync } from "node:fs";
import { resolve } from "node:path";

// ---------------------------------------------------------------------------
// Configuration — mirrors auth.js and server.js env var conventions
// ---------------------------------------------------------------------------

const CLIENT_ID = process.env.SITECORE_CLIENT_ID;
const CLIENT_SECRET = process.env.SITECORE_CLIENT_SECRET || "";
const TOKEN_URL =
  process.env.SITECORE_TOKEN_URL || "https://auth.sitecorecloud.io/oauth/token";
const AUDIENCE =
  process.env.SITECORE_AUDIENCE || "https://api.sitecorecloud.io";

// Token file lives in the proxy working directory (same as auth.js)
const TOKEN_FILE = resolve(process.cwd(), "tokens.json");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Pretty-prints a section header to stdout.
 * @param {string} title - The section title to display
 */
function header(title) {
  console.log(`\n${"=".repeat(50)}`);
  console.log(`  ${title}`);
  console.log(`${"=".repeat(50)}\n`);
}

/**
 * Formats a duration in seconds into a human-readable string.
 * @param {number} seconds - Duration in seconds
 * @returns {string} Human-readable duration (e.g. "1h 30m 0s")
 */
function formatDuration(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return `${h}h ${m}m ${s}s`;
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  header("Sitecore Token Refresh Test");

  // -- Validate prerequisites -----------------------------------------------

  if (!CLIENT_ID) {
    console.error("ERROR: SITECORE_CLIENT_ID environment variable is required.");
    console.error("");
    console.error("Set it before running this script:");
    console.error("  export SITECORE_CLIENT_ID=your-client-id");
    process.exit(1);
  }

  if (!existsSync(TOKEN_FILE)) {
    console.error(`ERROR: Token file not found at ${TOKEN_FILE}`);
    console.error("");
    console.error("Run the auth script first to generate tokens:");
    console.error("  npm run auth");
    process.exit(1);
  }

  // -- Load existing tokens -------------------------------------------------

  let tokenData;
  try {
    const raw = readFileSync(TOKEN_FILE, "utf-8");
    tokenData = JSON.parse(raw);
  } catch (err) {
    console.error(`ERROR: Failed to parse ${TOKEN_FILE}: ${err.message}`);
    process.exit(1);
  }

  const oldTokens = tokenData.tokens;
  if (!oldTokens || !oldTokens.refresh_token) {
    console.error("ERROR: No refresh_token found in tokens.json.");
    console.error("Re-run the auth script: npm run auth");
    process.exit(1);
  }

  // Capture the old state for comparison
  const oldExpiry = tokenData.tokenExpires || "unknown";
  const oldRefreshToken = oldTokens.refresh_token;
  // Grab last 8 chars of tokens for safe display (never log full tokens)
  const oldAccessSuffix = oldTokens.access_token
    ? `...${oldTokens.access_token.slice(-8)}`
    : "N/A";
  const oldRefreshSuffix = `...${oldRefreshToken.slice(-8)}`;

  console.log("Loaded existing tokens from:", TOKEN_FILE);
  console.log(`  Access token:  ${oldAccessSuffix}`);
  console.log(`  Refresh token: ${oldRefreshSuffix}`);
  console.log(`  Token expiry:  ${oldExpiry}`);
  console.log(`  Token URL:     ${TOKEN_URL}`);
  console.log(`  Client ID:     ${CLIENT_ID}`);
  console.log(`  Audience:      ${AUDIENCE}`);

  // -- Perform token refresh ------------------------------------------------

  header("Requesting Token Refresh");

  const body = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: oldRefreshToken,
    client_id: CLIENT_ID,
    audience: AUDIENCE,
  });

  // Include client_secret if configured (confidential client flow)
  if (CLIENT_SECRET) {
    body.set("client_secret", CLIENT_SECRET);
  }

  console.log("Sending POST to token endpoint...");

  let response;
  try {
    response = await fetch(TOKEN_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: body.toString(),
    });
  } catch (err) {
    console.error(`ERROR: Network request failed: ${err.message}`);
    process.exit(1);
  }

  if (!response.ok) {
    const errorText = await response.text();
    console.error(`ERROR: Token refresh failed (HTTP ${response.status}):`);
    console.error(errorText);
    process.exit(1);
  }

  const data = await response.json();

  // -- Analyze the response -------------------------------------------------

  header("Refresh Results");

  const newAccessSuffix = data.access_token
    ? `...${data.access_token.slice(-8)}`
    : "N/A";
  const newRefreshToken = data.refresh_token || oldRefreshToken;
  const newRefreshSuffix = `...${newRefreshToken.slice(-8)}`;
  const newExpiry = new Date(
    Date.now() + (data.expires_in || 0) * 1000
  ).toISOString();
  const ttlSeconds = data.expires_in || 0;

  console.log("New access token:  ", newAccessSuffix);
  console.log("New refresh token: ", newRefreshSuffix);
  console.log("Token type:        ", data.token_type || "unknown");
  console.log("Scope:             ", data.scope || "unknown");
  console.log("Expires in:        ", `${ttlSeconds}s (${formatDuration(ttlSeconds)})`);
  console.log("New token expiry:  ", newExpiry);
  console.log("Old token expiry:  ", oldExpiry);

  // Check if the refresh token was rotated
  const refreshRotated = data.refresh_token && data.refresh_token !== oldRefreshToken;
  console.log("");
  if (refreshRotated) {
    console.log("REFRESH TOKEN: ROTATED (new refresh token received and saved)");
  } else if (data.refresh_token) {
    console.log("REFRESH TOKEN: UNCHANGED (same refresh token returned)");
  } else {
    console.log("REFRESH TOKEN: NOT RETURNED (reusing existing refresh token)");
  }

  // -- Save updated tokens --------------------------------------------------

  header("Saving Updated Tokens");

  // Build the updated token file — matches the format from auth.js and
  // the _persist() method in mcp-client.js's FileTokenProvider
  const updatedTokenData = {
    tokens: {
      access_token: data.access_token,
      token_type: data.token_type || "Bearer",
      expires_in: data.expires_in,
      // Use the new refresh token if rotated, otherwise keep the old one
      refresh_token: newRefreshToken,
      scope: data.scope,
    },
    clientInfo: tokenData.clientInfo || null,
    tokenExpires: newExpiry,
    updated: new Date().toISOString(),
  };

  try {
    writeFileSync(TOKEN_FILE, JSON.stringify(updatedTokenData, null, 2), {
      mode: 0o600, // Owner-only read/write for security
    });
    console.log(`Tokens saved to: ${TOKEN_FILE}`);
  } catch (err) {
    console.error(`ERROR: Failed to write ${TOKEN_FILE}: ${err.message}`);
    process.exit(1);
  }

  // -- Summary --------------------------------------------------------------

  header("Test Summary");

  console.log("  [PASS] Refresh token accepted by Sitecore Identity");
  console.log(`  [PASS] New access token received (TTL: ${formatDuration(ttlSeconds)})`);
  console.log(
    `  [INFO] Refresh token ${refreshRotated ? "was ROTATED" : "was NOT rotated"}`
  );
  console.log("  [PASS] Updated tokens saved to disk");
  console.log("");
  console.log("Token refresh flow is working correctly.");
}

main().catch((err) => {
  console.error("\nFATAL:", err.message);
  process.exit(1);
});
